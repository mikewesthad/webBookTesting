<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" http-equiv="Content-Style-Type"/>
<meta content="pandoc" name="generator"/>
<title>ofBook - Ooops! = Object Oriented Programming + Classes</title>
<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
<link href="../style/bootstrap.min.css" rel="stylesheet">
<link href="../style/style.css" rel="stylesheet" type="text/css"/>
<link href="http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic,700italic|Merriweather:400,300,300italic,400italic,700,900,700italic,900italic" rel="stylesheet" type="text/css">
<script src="../javascript/jquery-1.8.3.min.js"></script>
<script src="../javascript/bootstrap.min.js"></script>
<script src="../javascript/navbar.js"></script>
</link></link></head>
<body>
<div class="banner">
<div class="content-wrapper">
<b>Work in progress!</b>
        This is a preliminary version of the <a href="https://github.com/openframeworks/ofBook/" target="_blank">ofBook</a>
</div>
</div>
<div class="content-wrapper">
<nav role="navigation">
<ul id="nav-parts"><li class="group">Foreword<ul><li class="chapter"><a href="foreword.html">Foreword</a><ul><li class="section selected"><a href="#aboutthisbook" target="_top">about this book</a></li><li class="section"><a href="#credits" target="_top">credits</a></li></ul></li></ul></li><li class="group selected">Basics<ul><li class="chapter"><a href="of_philosophy.html">philosophy</a><ul><li class="section selected"><a href="#ofstructure" target="_top">OF structure</a></li><li class="section"><a href="#projectgenerator" target="_top">project generator</a></li><li class="section"><a href="#handcpp" target="_top">.h and .cpp</a></li><li class="section"><a href="#setupupdatedraw" target="_top">setup/update/draw</a></li><li class="section"><a href="#preprocessorcompilerlinker" target="_top">preprocessor/compiler/linker</a></li></ul></li></ul><ul><li class="chapter"><a href="cplusplus_basics.html">C++ Language Basics</a><ul><li class="section selected"><a href="#lookalive" target="_top">Look Alive!</a></li><li class="section"><a href="#iteration" target="_top">Iteration</a></li><li class="section"><a href="#compilingmyfirstapp" target="_top">Compiling My First App</a></li><li class="section"><a href="#beyondhelloworld" target="_top">Beyond Hello World</a></li><li class="section"><a href="#functions" target="_top">Functions</a></li><li class="section"><a href="#customfunctions" target="_top">Custom Functions</a></li><li class="section"><a href="#encapsulationofcomplexity" target="_top">Encapsulation of Complexity</a></li><li class="section"><a href="#variablespart1" target="_top">Variables (part 1)</a></li><li class="section"><a href="#conclusion" target="_top">Conclusion</a></li><li class="section"><a href="#ps" target="_top">PS.</a></li></ul></li></ul><ul><li class="chapter"><a href="setup_and_project_structure.html">OF structure</a><ul><li class="section selected"><a href="#firstthingsfirst" target="_top">First things first</a></li><li class="section"><a href="#welcometoyournewkitchen" target="_top">Welcome to your new kitchen</a></li><li class="section"><a href="#runningexamples" target="_top">Running examples</a></li><li class="section"><a href="#offolderstructure" target="_top">OF folder structure</a></li></ul></li></ul><ul><li class="chapter"><a href="intro_to_graphics.html">Graphics</a><ul><li class="section selected"><a href="#brusheswithbasicshapes" target="_top">Brushes with Basic Shapes</a></li><li class="section"><a href="#brushesfromfreeformshapes" target="_top">Brushes from Freeform Shapes</a></li><li class="section"><a href="#movingtheworld" target="_top">Moving The World</a></li><li class="section"><a href="#nextsteps" target="_top">Next Steps</a></li></ul></li></ul><ul><li class="chapter selected"><a href="OOPs!.html">Ooops! = Object Oriented Programming + Classes</a><ul><li class="section selected"><a href="#overview" target="_top">Overview</a></li><li class="section"><a href="#whatisoop" target="_top">What is OOP</a></li><li class="section"><a href="#howtobuildyourownclassessimpleclass" target="_top">How to build your own Classes (simple Class)</a></li><li class="section"><a href="#makeanobjectfromyourclass" target="_top">make an Object from your Class</a></li><li class="section"><a href="#makeobjectsfromyourclass" target="_top">make objects from your Class</a></li><li class="section"><a href="#makemoreobjectsfromyourclass" target="_top">make more Objects from your Class</a></li><li class="section"><a href="#makeevenmoreobjectsfromyourclasspropertiesandconstructors" target="_top">make even more Objects from your Class: properties and constructors</a></li><li class="section"><a href="#makeevenmoreobjectsfromyourclass" target="_top">make even more Objects from your Class</a></li><li class="section"><a href="#makeanddeleteasyouwishusingvectors" target="_top">Make and delete as you wish - using vectors</a></li><li class="section"><a href="#quickintrotopolymorphisminheritance" target="_top">Quick intro to polymorphism (inheritance)</a></li></ul></li></ul></li><li class="group">Approaches<ul><li class="chapter"><a href="animation.html">Animation</a><ul><li class="section selected"><a href="#background" target="_top">Background</a></li><li class="section"><a href="#animationinofusefulconcepts" target="_top">Animation in OF / useful concepts:</a></li><li class="section"><a href="#linearmovement" target="_top">linear movement</a></li><li class="section"><a href="#functionbasedmovement" target="_top">Function based movement</a></li><li class="section"><a href="#simulation" target="_top">Simulation</a></li><li class="section"><a href="#wheretogofurther" target="_top">where to go further</a></li></ul></li></ul><ul><li class="chapter"><a href="data_vis.html">Information Visualization Chapter</a><ul><li class="section selected"><a href="#intro" target="_top">Intro</a></li><li class="section"><a href="#workingwithdatafilesinopenframeworks" target="_top">Working with data files in OpenFrameworks</a></li><li class="section"><a href="#moreusefulfunctionsforworkingwithdata" target="_top">More Useful functions for working with data</a></li><li class="section"><a href="#workingwithapis" target="_top">Working with APIs</a></li><li class="section"><a href="#furtherresources" target="_top">Further resources</a></li><li class="section"><a href="#references" target="_top">References</a></li></ul></li></ul><ul><li class="chapter"><a href="game_design.html">Experimental Game Development in openFrameworks</a><ul><li class="section selected"><a href="#howdogamedevelopersactuallymakegames" target="_top">How do game developers actually make games?</a></li><li class="section"><a href="#sowhatisoscanyway" target="_top">So what is OSC, anyway?</a></li><li class="section"><a href="#ourbasicgamemakingitnotsobasic" target="_top">Our basic game--&amp; making it not-so-basic</a></li></ul></li></ul><ul><li class="chapter"><a href="image_processing_computer_vision.html">Image Processing and Computer Vision</a><ul><li class="section selected"><a href="#preliminariestoimageprocessing" target="_top">Preliminaries to Image Processing</a></li></ul></li></ul></li><li class="group">I/O<ul><li class="chapter"><a href="hardware.html">hardware</a><ul><li class="section selected"><a href="#introduction" target="_top">introduction</a></li><li class="section"><a href="#gettingstartedwithserialcommunication" target="_top">getting started with serial communication</a></li><li class="section"><a href="#digitalandanalogcommunication" target="_top">digital and analog communication</a></li><li class="section"><a href="#usingserialforcommunicationbetweenarduinoandopenframeworks" target="_top">using serial for communication between arduino and openframeworks</a></li><li class="section"><a href="#lightsoncontrollinghardwareviadmx" target="_top">Lights On - controlling hardware via DMX</a></li><li class="section"><a href="#raspberrypigettingyourofappintosmallspaces" target="_top">Raspberry Pi - getting your OF app into small spaces</a></li></ul></li></ul><ul><li class="chapter"><a href="sound.html">Sound</a><ul><li class="section selected"><a href="#gettingstartedwithsoundfiles" target="_top">Getting Started With Sound Files</a></li><li class="section"><a href="#gettingstartedwiththesoundstream" target="_top">Getting Started With the Sound Stream</a></li><li class="section"><a href="#why1to1" target="_top">Why -1 to 1?</a></li><li class="section"><a href="#timedomainvsfrequencydomain" target="_top">Time Domain vs Frequency Domain</a></li><li class="section"><a href="#reactingtoliveaudio" target="_top">Reacting to Live Audio</a></li><li class="section"><a href="#synthesizingaudio" target="_top">Synthesizing Audio</a></li><li class="section"><a href="#audiogotchas" target="_top">Audio Gotchas</a></li></ul></li></ul><ul><li class="chapter"><a href="network.html">Network</a><ul><li class="section selected"><a href="#tcpvsudp" target="_top">TCP vs UDP</a></li><li class="section"><a href="#osc" target="_top">OSC</a></li></ul></li></ul></li><li class="group">Advanced topics<ul><li class="chapter"><a href="advanced_graphics.html">Advanced graphics</a><ul><li class="section selected"><a href="#dimmediatemodevsofpolylineofpath" target="_top">2D, immediate mode vs ofPolyline/ofPath</a></li><li class="section"><a href="#d" target="_top">3D</a></li></ul></li></ul><ul><li class="chapter"><a href="math.html">That Math Chapter: From 1D to 4D</a><ul><li class="section selected"><a href="#howartistsapproachmath" target="_top">How Artists Approach Math</a></li><li class="section"><a href="#aboutthischapter" target="_top">About this Chapter</a></li><li class="section"><a href="#onedimensionusingchange" target="_top">One Dimension: Using Change</a></li><li class="section"><a href="#moredimensionssomelinearalgebra" target="_top">More Dimensions: Some Linear Algebra</a></li></ul></li></ul><ul><li class="chapter"><a href="memory.html">Memory in C++</a><ul><li class="section selected"><a href="#computermemoryandvariables" target="_top">Computer memory and variables</a></li><li class="section"><a href="#stackvariablesvariablesinfunctionsvsvariablesinobjects" target="_top">Stack variables, variables in functions vs variables in objects</a></li><li class="section"><a href="#pointersandreferences" target="_top">Pointers and references</a></li><li class="section"><a href="#variablesintheheap" target="_top">Variables in the heap</a></li><li class="section"><a href="#memorystructuresarraysandvectors" target="_top">Memory structures, arrays and vectors</a></li><li class="section"><a href="#othermemorystructureslistsandmaps" target="_top">Other memory structures, lists and maps</a></li><li class="section"><a href="#smartpointers" target="_top">smart pointers</a></li></ul></li></ul><ul><li class="chapter"><a href="threads.html">Threads</a><ul><li class="section selected"><a href="#whatsathreadandwhentouseit" target="_top">What's a thread and when to use it</a></li><li class="section"><a href="#ofthread" target="_top">ofThread</a></li><li class="section"><a href="#threadsandopengl" target="_top">Threads and openGL</a></li><li class="section"><a href="#ofmutex" target="_top">ofMutex</a></li><li class="section"><a href="#externalthreadsanddoublebuffering" target="_top">External threads and double buffering</a></li><li class="section"><a href="#ofscopedlock" target="_top">ofScopedLock</a></li><li class="section"><a href="#pococondition" target="_top">Poco::Condition</a></li><li class="section"><a href="#conclusion" target="_top">Conclusion</a></li></ul></li></ul><ul><li class="chapter"><a href="ios.html">ofxiOS</a><ul><li class="section selected"><a href="#openframeworksoniosdevices" target="_top">OpenFrameworks on iOS devices.</a></li><li class="section"><a href="#intro" target="_top">Intro</a></li><li class="section"><a href="#introtoobjectivec" target="_top">Intro to Objective-C</a></li><li class="section"><a href="#underthehood" target="_top">Under the Hood</a></li><li class="section"><a href="#ofuikit" target="_top">OF &amp; UIKit</a></li><li class="section"><a href="#mediaplaybackandcapture" target="_top">Media Playback and Capture</a></li><li class="section"><a href="#lifehacks" target="_top">Life Hacks</a></li><li class="section"><a href="#appstore" target="_top">App Store</a></li><li class="section"><a href="#casestudies" target="_top">Case Studies</a></li></ul></li></ul><ul><li class="chapter"><a href="c++11.html">C++ 11</a><ul><li class="section selected"><a href="#blahblah" target="_top">Blah blah</a></li><li class="section"><a href="#auto" target="_top">auto</a></li><li class="section"><a href="#forthingthings" target="_top">for (thing : things)</a></li><li class="section"><a href="#override" target="_top">override</a></li><li class="section"><a href="#lambdafunctions" target="_top">Lambda functions</a></li></ul></li></ul></li><li class="group">Project breakdowns<ul><li class="chapter"><a href="project_elliot.html">Case Study : Line Segments Space</a><ul><li class="section selected"><a href="#foreward" target="_top">Foreward</a></li><li class="section"><a href="#artiststatement" target="_top">Artist statement</a></li><li class="section"><a href="#digitalemulsion" target="_top">Digital Emulsion</a></li><li class="section"><a href="#technicalsolution" target="_top">Technical solution</a></li><li class="section"><a href="#designtimeapplications" target="_top">Design time applications</a></li></ul></li></ul><ul><li class="chapter"><a href="project_eva.html">Case Study: Choreographies for Humans and Stars</a><ul><li class="section selected"><a href="#projectoverview" target="_top">Project Overview</a></li><li class="section"><a href="#ideationandprototyping" target="_top">Ideation and Prototyping</a></li><li class="section"><a href="#findingthetechnicalsolutions" target="_top">Finding the Technical Solutions</a></li><li class="section"><a href="#developingthevisualizationsoftware" target="_top">Developing the Visualization Software</a></li><li class="section"><a href="#failsafesanddirtyfixes" target="_top">Fail-safes and dirty fixes</a></li><li class="section"><a href="#resultsandreception" target="_top">Results and Reception</a></li></ul></li></ul><ul><li class="chapter"><a href="project_joel.html">Case Study: Anthropocene, an interactive film installation for Greenpeace as part of their field at Glastonbury 2013</a><ul><li class="section selected"><a href="#projectoverview" target="_top">Project Overview</a></li><li class="section"><a href="#theproject" target="_top">The Project</a></li><li class="section"><a href="#development" target="_top">Development</a></li><li class="section"><a href="#showtime" target="_top">Show time</a></li><li class="section"><a href="#postevent" target="_top">Post Event</a></li><li class="section"><a href="#teamandcredits" target="_top">Team and Credits</a></li><li class="section"><a href="#hardwareselection" target="_top">Hardware selection</a></li><li class="section"><a href="#appendix1codestructuremainloop" target="_top">Appendix 1: Code structure, main loop</a></li><li class="section"><a href="#appendix2modeswithscreengrabsandcodeexplanation" target="_top">Appendix 2: Modes, with screen grabs and code explanation</a></li><li class="section"><a href="#appendix3editeddevelopmentnotes" target="_top">Appendix 3: Edited development notes</a></li></ul></li></ul></li><li class="group">Tools<ul><li class="chapter"><a href="version_control_with_git.html">Version control with Git</a><ul><li class="section selected"><a href="#whatisversioncontrolandwhyshouldyouuseit" target="_top">What is version control, and why should you use it?</a></li><li class="section"><a href="#differentversioncontrolsystems" target="_top">Different version control systems</a></li><li class="section"><a href="#introductiontogit" target="_top">Introduction to Git</a></li><li class="section"><a href="#popularguiclients" target="_top">Popular GUI clients</a></li><li class="section"><a href="#conclusion" target="_top">Conclusion</a></li></ul></li></ul><ul><li class="chapter"><a href="ofSketch.html">ofSketch</a><ul><li class="section selected"><a href="#whatisofsketch" target="_top">What is ofSketch?</a></li><li class="section"><a href="#download" target="_top">Download</a></li><li class="section"><a href="#sketchformat" target="_top">Sketch Format</a></li><li class="section"><a href="#remotecoding" target="_top">Remote Coding</a></li><li class="section"><a href="#future" target="_top">Future</a></li></ul></li></ul><ul><li class="chapter"><a href="installation_up_4evr_macosx.html">Installation up 4evr - OSX</a><ul><li class="section selected"><a href="#step1prepyoursoftwareandthecomputer" target="_top">Step 1: Prep your software and the computer</a></li><li class="section"><a href="#step2bootintoyoursoftware" target="_top">Step 2: Boot into your software</a></li><li class="section"><a href="#step3keepitupchamp" target="_top">Step 3: Keep it up (champ!)</a></li><li class="section"><a href="#step4rebootperiodically" target="_top">Step 4: Reboot periodically</a></li><li class="section"><a href="#step5checkinonitfromafar" target="_top">Step 5: Check in on it from afar</a></li><li class="section"><a href="#step6testtesttest" target="_top">Step 6: Test, test, test.</a></li><li class="section"><a href="#additionaltipslogging" target="_top">Additional Tips: Logging</a></li><li class="section"><a href="#memoryleakmurderer" target="_top">Memory leak murderer</a></li><li class="section"><a href="#alternateresources" target="_top">Alternate resources</a></li></ul></li></ul><ul><li class="chapter"><a href="installation_up_4evr_linux.html">Installation up 4evr - Linux</a><ul><li class="section selected"><a href="#someadditionaltricks" target="_top">Some additional tricks:</a></li></ul></li></ul></li></ul>
</nav>
<div class="chapter-content">
<h1 id="ooops-object-oriented-programming-classes">Ooops! = Object Oriented Programming + Classes</h1>
<h2 id="overview">Overview</h2>
<p>This tutorial is an quick and practical introduction to Object Oriented Programming in openFrameworks and a how-to guide to build and use your own classes. By the end of this chapter you should understand how to create your own objects and have a lot of balls bouncing on your screen!</p>
<h2 id="whatisoop">What is OOP</h2>
<p>Object Oriented Programming is a programming paradigm based on the use of objects and their interactions. Some terms and definitions used within OOP are listed below:</p>
<p>-A Class defines the characteristics of a thing - the object - and its behaviors; it defines not only its properties and attributes but also what it can do.</p>
<p>-An Object is an instance of a class.</p>
<p>-The Methods are the objects abilities and how we can call them.</p>
<p>A recurring analogy is to see a Class as a the cookie cutter and the cookies as the Objects.</p>
<p>Note: please see chapter (Josh Nimoy's) for amore detailed explanation of Objected Oriented languages.</p>
<h2 id="howtobuildyourownclassessimpleclass">How to build your own Classes (simple Class)</h2>
<p>Classes and objects are similar to the concepts of movie clips and instances in Flash and are also a fundamental part of Java programming. Because like coding, cooking is fun and we tend to experiment in the kitchen let's continue with the classic metaphor of a cookie cutter as a class and cookies as the objects. Every class has two files: a header file, also known as a Declarations file with the termination '.h' and an implementation file, terminating in '.cpp'. A very easy way of knowing what these two files do is to think of the header file (.h) as a recipe, a list of the main ingredients of your cookie. The implementation file (.cpp) is what we're going to do with them, how you mix and work them to be the perfect cookie! So let's see how it works:</p>
<p>first of all let's create the two class files: If you're using XCODE as your IDE (it stands for: Integrated Development Environment), select the src folder and left Click (or CTRL + click), on the pop menu select 'New File' and you'll be taken to a new window menu, choose the appropriate platform you're developping for (OSX or iOS) and select C++ class and finally choose a name (we used 'ofBall'). You'll automatically see the two files in your 'src' folder: ofBall.h and ofBall.cpp . Now let's edit your class header (.h) file. Feel free to delete all its contents and let's start from scratch: Declare a class in the header file (.h). In this case, the file name should be ofBall.h. Folllow the code below and type into your own ofBall.h file, please note the comments I've included to guide you along.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#ifndef _OF_BALL </span><span class="co">// if this class hasn't been defined, the program can define it</span>
<span class="ot">#define _OF_BALL </span><span class="co">// by using this if statement you prevent the class to be called more than once which would confuse the compiler</span>
<span class="ot">#include "ofMain.h" </span><span class="co">// we need to include this to have a reference to the OpenFrameworks framework</span>
<span class="kw">class</span> ofBall {
    
    <span class="kw">public</span>: <span class="co">// place public functions or variables declarations here</span>
    
    <span class="co">// methods, equivalent to specific functions of your class objects</span>
    <span class="dt">void</span> update();  <span class="co">// update method, used to refresh your objects properties</span>
    <span class="dt">void</span> draw();    <span class="co">// draw method, this where you'll do the object's drawing </span>
    
    <span class="co">// variables</span>
    <span class="dt">float</span> x;      <span class="co">// position</span>
    <span class="dt">float</span> y;
    <span class="dt">float</span> speedY; <span class="co">// speed and direction</span>
    <span class="dt">float</span> speedX;
    <span class="dt">int</span> dim;      <span class="co">// size</span>
    ofColor color; <span class="co">// color using ofColor type</span>
    
    ofBall(); <span class="co">// constructor - used to initialize an object, if no properties are passed the program sets them to the default value</span>
    <span class="kw">private</span>: <span class="co">// place private functions or variables declarations here</span>
}; <span class="co">// don't forget the semicolon!!</span>
<span class="ot">#endif </span></code></pre>
<p>We have declared the Ball class header file (the list of ingredients) and now lets get to the cooking part <strong>[KL: I wouldn't use an arrow symbol within this text.]</strong> <strong>[RX: KL: do you mean excluding the point exmples to keep it simple?]</strong> to see what these ingredients can do! Please notice the '#include' tag, this is a way to tell the compiler which file to include for each implementation file. When the program is compiled these '#include' tags will be replaced by the original file they're referring to. The 'if statement' (#ifndef) is a way to prevent the repetition of header files which could easily occur, by using this expression it helps the compiler to only include the file once and avoid repetition. Don't worry about this now, we'll talk about it later on!</p>
<p>Here's how you can write the class *.cpp file, the implementation file:</p>
<p><strong>[KL: did the previous chapter talk about how to create a new class in oF? If so, no worries, but if it didn't, it's a good idea to address how to do that, and that the example below is ofBall.cpp. - see below]</strong> <strong>[JTN: yes it did but only in the unabridged version - see below ]</strong> <strong>[RX: added xcode instructions below, anyone up to help with other IDEs? ]</strong></p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include "ofBall.h"</span>

ofBall::ofBall(){
    x = ofRandom(<span class="dv">0</span>, ofGetWidth());      <span class="co">// give some random positioning</span>
    y = ofRandom(<span class="dv">0</span>, ofGetHeight());
    
    speedX = ofRandom(<span class="dv">-1</span>, <span class="dv">1</span>);           <span class="co">// and random speed and direction</span>
    speedY = ofRandom(<span class="dv">-1</span>, <span class="dv">1</span>);
    
    dim = <span class="dv">20</span>;
    
    color.set(ofRandom(<span class="dv">255</span>),ofRandom(<span class="dv">255</span>),ofRandom(<span class="dv">255</span>)); <span class="co">// one way of defining digital color is by adddressing its 3 components individually (Red, Green, Blue) in a value from 0-255, in this example we're setting each to a random value</span>
}


<span class="dt">void</span> ofBall::update(){
    <span class="kw">if</span>(x &lt; <span class="dv">0</span> ){
        x = <span class="dv">0</span>;
        speedX *= <span class="dv">-1</span>;
    } <span class="kw">else</span> <span class="kw">if</span>(x &gt; ofGetWidth()){
        x = ofGetWidth();
        speedX *= <span class="dv">-1</span>;
    }
    
    <span class="kw">if</span>(y &lt; <span class="dv">0</span> ){
        y = <span class="dv">0</span>;
        speedY *= <span class="dv">-1</span>;
    } <span class="kw">else</span> <span class="kw">if</span>(y &gt; ofGetHeight()){
        y = ofGetHeight();
        speedY *= <span class="dv">-1</span>;
    } 
    
    x+=speedX;
    y+=speedY;
}

<span class="dt">void</span> ofBall::draw(){
    ofSetColor(color);
    ofCircle(x, y, dim);
} </code></pre>
<p>Now, this is such a simple program that we could have wirtten it inside our OfApp(.h and .cpp) files and it wouldn;t be senseless to do if we didn;t want to re-use this code. In there lyes one of the advantages of Object Oriented Programming: re-use: Imagine we want to create thousands of these balls and how easily the ocde could get messy and extended, by creating our own class we can later re-create as many objects as need from it and just call the appropriate methods when needed keeping our code clean and eficient. In a more pragamatic example think of creating a class for each of your UI elements (button, slider, etc) and hopw easy it would be to them deploy them in your program but also to include and re-use them in future programs.</p>
<p><strong>[KL: Explain exactly why we are creating this class outside of ofApp. This and the explanation below seem kind of rushed and OOP can benefit by using some real life analogies to demonstrate class relationships.]</strong></p>
<h2 id="makeanobjectfromyourclass">make an Object from your Class</h2>
<p>Now that we've created a class let's make the real object! In your testApp.h (header file) we'll have to declare a new object and get some free memory for it. But first we need to include (or give the instructions to do so) your ofBall class in our program. To do this we need to write:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include "ofBall.h"</span></code></pre>
<p>on the top of your testApp.h file. Then we can finally declare an instance of the class i our progam:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">ofBall myBall;</code></pre>
<p>Now let's get that ball bouncing on screen! Go to your project testApp.cpp (implementation) file. Now that we've created the object, we just need to draw it and update its values by calling its methods. In the update() function, add:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">myBall.update();  <span class="co">// calling the object's update method</span></code></pre>
<p>and in the draw() function lets add:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">myBall.draw();  <span class="co">// call the draw method to draw the object</span></code></pre>
<p>Compile and run! By now you must be seeing a bouncing ball on the screen! Great!</p>
<h2 id="makeobjectsfromyourclass">make objects from your Class</h2>
<p>By now, you're probably asking yourself why you went to so much trouble to create a bouncing ball. You could have done this (and probably have) without using classes. In fact one of the advantages of using classes is to be able to create multiple individual objects with the same characteristics. So, let's do that now! Go back to your ofApp.h file and create a couple of new objects:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">ofBall myBall1;
ofBall myBall2;
ofBall myBall3;</code></pre>
<p>In the implementation file (ofApp.cpp), call the corresponding methods for each of the objects</p>
<p>in the ofApp's update() function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">myBall1.update();
myBall2.update();
myBall3.update();</code></pre>
<p>and also in the draw() function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">myBall1.draw();
myBall2.draw();
myBall3.draw();</code></pre>
<h2 id="makemoreobjectsfromyourclass">make more Objects from your Class</h2>
<p>We've just created 3 objects but what if we wanted to created 10, 100 or maybe 1000's of them?! Hardcoding one by one would be a painful and long process that can be easily solved by automating the object creation and function calls. Just by using a couple for loops we'll make this process simpler and cleaner. Instead of declaring a list of objects one by one we'll create an array of objects of type 'ofBall'. We'll also introduce another new element: a constant. Constants are defined after the #includes as #define CONSTANT_NAME value. This is a way of defining a constant value that won't ever change in the program:</p>
<p><strong>[KL: The pseudo code-like explanation above is an effective approach. This is a good method to use before writing out the ofBall class above, too. Also, I've been taking out words like "just" before steps and simplifying verb tenses for clarity. I'd keep that in mind as you continue writing this chapter. The more concise, the better.]</strong> <strong>[KL: Restate which file this is happening in.]</strong> in the testApp class header file, where you define the balls objects also define the constant that we'll use for the number of objects:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define NBALLS 5</span></code></pre>
<p>we'll now use the CONSTANT value to define the size of our array of objects:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">ofBall myBall[NBALLS];</code></pre>
<p>back to our implementation file we'll just need to create an array of objects and call their methods through 'for' loops. in the update() function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;NBALLS; i++){
    myBall[i].update();
}</code></pre>
<p>in the draw() function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;NBALLS; i++){
    myBall[i].draw();
}</code></pre>
<h2 id="makeevenmoreobjectsfromyourclasspropertiesandconstructors">make even more Objects from your Class: properties and constructors</h2>
<p>As we've seen, each of the objects has a set of properties defined by its variables (position, speed, direction, and dimension). Another advantage of object oriented programming is that the objects created can have different values for each of its properties. For us to have better control of each object, we can have a constructor that defines these characteristics and lets us access them. In the ofBall definitions file (*.h) we can change the constructor to include some of the object's properties (let's say position and dimension):</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">ofBall(<span class="dt">float</span> x, <span class="dt">float</span> y, <span class="dt">int</span> dim);</code></pre>
<p>Since we've changed the constructor, we'll need to update the ofBall implementation (*.cpp) file to reflect these.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">ofBall::ofBall(<span class="dt">float</span> _x, <span class="dt">float</span> _y, <span class="dt">int</span> _dim){
    x = _x;
    y = _y;
    dim = _dim;
    
    speedX = ofRandom(<span class="dv">-1</span>, <span class="dv">1</span>);
    speedY = ofRandom(<span class="dv">-1</span>, <span class="dv">1</span>);
}</code></pre>
<p>Your ofBall.cpp file should look like this by now:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include "ofBall.h"</span>

ofBall::ofBall(<span class="dt">float</span> _x, <span class="dt">float</span> _y, <span class="dt">int</span> _dim){
        x = _x;
        y = _y;
        dim = _dim;
       
        speedX = ofRandom(<span class="dv">-1</span>, <span class="dv">1</span>);
        speedY = ofRandom(<span class="dv">-1</span>, <span class="dv">1</span>);
    
        color.set(ofRandom(<span class="dv">255</span>), ofRandom(<span class="dv">255</span>), ofRandom(<span class="dv">255</span>));
    
}


<span class="dt">void</span> ofBall::update(){
    
    <span class="kw">if</span>(x &lt; <span class="dv">0</span> ){
        x = <span class="dv">0</span>;
        speedX *= <span class="dv">-1</span>;
    } <span class="kw">else</span> <span class="kw">if</span>(x &gt; ofGetWidth()){
        x = ofGetWidth();
    speedX *= <span class="dv">-1</span>;
    }

    <span class="kw">if</span>(y &lt; <span class="dv">0</span> ){
        y = <span class="dv">0</span>;
        speedY *= <span class="dv">-1</span>;
    } <span class="kw">else</span> <span class="kw">if</span>(y &gt; ofGetHeight()){
        y = ofGetHeight();
        speedY *= <span class="dv">-1</span>;
    }
     
    x+=speedX;
    y+=speedY;
    
}

<span class="dt">void</span> ofBall::draw(){
    ofSetColor(color);
    ofCircle(x, y, dim);
}</code></pre>
<p>By implementing these changes we'll also need to create space in memory for these objects. We'll do this by creating a pointer (a reference in memory) for each object. Back to the ofApp.h (definitions) file we'll declare a new object like this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">ofBall *myBall;  </code></pre>
<p>The star(*) means it will be created in a reserved part of memory just for it, we'll dynamically allocate this instance of the ofBall class.</p>
<p><strong>[KL: specify why we'd make it into a pointer vs not a pointer]</strong></p>
<p>Now in the TestApp.cpp file we will need to create the object in the setup and we'll call the object's methods on the draw() and update() functions in a different way than before. Instead of using the (.) dot syntax like we have been doing so far, from now on we'll use the (-&gt;) arrow syntax. Also, we'll also be creating a new instance way more explicitily. So, in setup()</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">            <span class="co">// x-position,        y-position,           size</span>
myBall = <span class="kw">new</span> ofBall(ofRandom(<span class="dv">300</span>,<span class="dv">400</span>), ofRandom(<span class="dv">200</span>,<span class="dv">300</span>), ofRandom(<span class="dv">10</span>,<span class="dv">40</span>));</code></pre>
<p>As you see it is now possible to directly control the objects properties on its creation. and now we'll just need to update and draw it.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">myBall-&gt;update();


myBall-&gt;draw();</code></pre>
<p><strong>[KL: We've changed myBall.update() to myBall-&gt;update(). That's kind of a big deal and warrants explanation concerning pointers.]</strong></p>
<p><strong>[JTN: no harm in explaining it twice, but i introduced it at the end of my unabridged chapter https://github.com/openframeworks/ofBook/blob/master/02_cplusplus_basics/unabridged.md#classes ]</strong></p>
<h2 id="makeevenmoreobjectsfromyourclass">make even more Objects from your Class</h2>
<p>In this part of our OOPs! tutorial <strong>[KL: I simplified two statements into one for concision.]</strong> we'll demonstrate an automation process to create objects from our previously built class. We'll create more <strong>[KL: "We'll create" works better than "we'll be creating." This is an example of verb tenses I've been changing. It's shorter and clearer.]</strong> objects by using arrays like we did in part 2.1 but this time we'll have to do some minor changes:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">ofBall** myBall;   <span class="co">// an array of pointers of type ofBall</span>
<span class="dt">int</span> nBalls;        <span class="co">//variable for the number of balls </span></code></pre>
<p>When creating an array of objects, instead of creating one pointer, we'll create an array of pointers. That's why we have two 'stars' and not one in the declarations(<em>.h) file. We have created a pointer to an array of pointers. Let's see how we'll create and call these objects in the implementation (</em>.cpp) file:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">nBalls = <span class="dv">5</span>; <span class="co">// the number of ball objects we want to create</span>

myBall = <span class="kw">new</span> ofBall*[nBalls]; <span class="co">// an array of pointers for the objects</span>

<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; nBalls; i++){
    <span class="dt">float</span> x = <span class="dv">20</span>+(<span class="dv">100</span>*i); <span class="co">// using the value of the counter variable(i) to differentiate them</span>
    <span class="dt">float</span> y = <span class="dv">20</span>+(<span class="dv">100</span>*i);
    <span class="dt">int</span> dim = <span class="dv">10</span>+(i*<span class="dv">10</span>);
        
    myBall[i] = <span class="kw">new</span> ofBall(x,y,dim);  <span class="co">// create each object from the array</span>
}</code></pre>
<p>similarly when we want to draw and update the objects we've created we'll need 'for' loops to run through the array.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; nBalls; i++){
    myBall[i]-&gt;update();
}



<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; nBalls; i++){
    myBall[i]-&gt;draw();
}</code></pre>
<p><strong>[KL: Great tutorial so far. The organization works well. I'm eager to see the rest. The main thing so far would be focusing on concision in your writing.]</strong></p>
<h2 id="makeanddeleteasyouwishusingvectors">Make and delete as you wish - using vectors</h2>
<p>In this part we'll look into more dynamic ways of creating and destroying objects from our class. Vectors are special arrays that don;t need a pre-fixed number of elements, that's their magic: vectors are elastic! note: You'll be hearing baout two different types of vectors throughout this book. Please don't confuse stl::vectors (the elastic arrays type we're talking about) with the math vectors (forces).</p>
<p>Back to our beloved testApp.h file, let's define a vector of ofBall objects by typing:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">vector &lt;ofBall*&gt; myBall;</code></pre>
<p>In this expression we're creating a type (vector) of type (ofBall pointers) and naming it myBall. Now, let's head to our (.cpp) and start cooking! Ignore the setup, update and draw methods for now, let's jump to</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> testApp::mouseDragged(<span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">int</span> button){
    
}</code></pre>
<p>In this method we're listening to the dragging activity of your mouse or trackpad and we'll use this simplicity to create interaction! So let's just create some code to create ofBalls and add them to our porgram when we drag the mouse.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> testApp::mouseDragged(<span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">int</span> button){
    ofBall *tempBall;
        tempBall = <span class="kw">new</span> ofBall(x,y, ofRandom(<span class="dv">10</span>,<span class="dv">40</span>));
        myBall.push_back(tempBall);
}</code></pre>
<p>A few new things in our code, first we declare a temporary object pointer, we them create it and assign 'x' and 'y' mouse Coordinates to it's contructor variables. We later use this temporary object as a shortcut to add ofBall objects to our vector. Back to our Update and Draw methids we can add the needed 'for loops' to iterate over the objects in the vector to update and draw them liek we would do with arrays. This time though we didn't declare a variable that stores the maximum number of objects but instead we call a method that vectors have that allwos us to know their size. See code below for Update:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span> ; i&lt;myBall.size(); i++) {
        myBall[i]-&gt;update();
    }</code></pre>
<p>and for Draw:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span> ; i&lt;myBall.size(); i++) {
    myBall[i]-&gt;draw();
}
</code></pre>
<p>Now let's also implement a way to delete them before we have way too many ofBalls: On the testApp::MousePressed Call we will loop though our vector and check the distance between the coordinates of the mouse with the ofBall position, if this distance is smaller than the ofBall dimension then, we know that we're clicking inside it, we can delete it. Because we're using the vecotr.erase method we need to use an iterator ( myBall.begin() ), a shortcut that references to the first element of the vector as a starting point to access the vector element we really want to erase ( 'i' ).</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span> (<span class="dt">int</span> i =<span class="dv">0</span>; i &lt; myBall.size(); i++) {
    <span class="dt">float</span> distance = ofDist(x,y, myBall[i]-&gt;x, myBall[i]-&gt;y); <span class="co">// a method OF give us to check the distance between two coordinates</span>
    
    <span class="kw">if</span> (distance &lt; myBall[i]-&gt;dim) {
        myBall.erase(myBall.begin()+i); <span class="co">// we need to use an iterator/ reference to the vector position we want to delete</span>
    }
}</code></pre>
<p>To learn more about stl::vector check xxx chapter or this online shory tutorial : http://www.openframeworks.cc/tutorials/c++%20concepts/001_stl_vectors_basic.html</p>
<h2 id="quickintrotopolymorphisminheritance">Quick intro to polymorphism (inheritance)</h2>
<p>You're now discovering the power of OOP, making a class and creating as many objects from that in an instant, adding and deleting by your application needs. Now, for a second let's go back to our cooking metaphor (yummi!) and imagine that your cookies, even sharing the same cookie cutter and dough using some different sprinkles on each won't hurt and add some desired variation to our cookie jar selection! This is also the power of OOP and inheritance: by allowing to use a base class and add some specific behaviours overwrite some of the behaviours of a class, creating a subset of instances / objects with slightly different behaviors. The great thing about this is it's repurposability, we're using the 'mother' class as a starting point, using all its capabilities but we overwrite one of its methods to give it more flexibility. Going back to our oFBall class intial version (step 1) we'll build some 'daughter' classes based on its main characteristics ( motion behaviors and shape) but we'll distinct each inherited subClass by using a different color on its drawing method. Your ofBall header file should look like this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#ifndef _OF_BALL </span><span class="co">// if this class hasn't been defined, the program can define it</span>
<span class="ot">#define _OF_BALL </span><span class="co">// by using this if statement you prevent the class to be called more than once which would         confuse the compiler</span>
<span class="ot">#include "ofMain.h"</span>


<span class="kw">class</span> ofBall {
    
<span class="kw">public</span>: <span class="co">// place public functions or variables declarations here</span>
        
<span class="dt">void</span> update();
<span class="dt">void</span> draw(); 

<span class="co">// variables</span>
<span class="dt">float</span> x;      
<span class="dt">float</span> y;
<span class="dt">float</span> speedY; 
<span class="dt">float</span> speedX;
<span class="dt">int</span> dim;      

ofColor color;
    
ofBall();

<span class="kw">private</span>: 

};
<span class="ot">#endif</span></code></pre>
<p>And let's make some slight changes on the implementation file: lets; chage the min and maximum values of the random size to larger values and set the position to the center of the screen.Make it look like this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include "ofBall.h"</span>

ofBall::ofBall(){
    x = ofGetWidth()*<span class="fl">.5</span>;
    y = ofGetHeight()*<span class="fl">.5</span>;
    dim = ofRandom(<span class="dv">200</span>,<span class="dv">250</span>);
    
    speedX = ofRandom(<span class="dv">-1</span>, <span class="dv">1</span>);
    speedY = ofRandom(<span class="dv">-1</span>, <span class="dv">1</span>);
    
    color.set(ofRandom(<span class="dv">255</span>), ofRandom(<span class="dv">255</span>), ofRandom(<span class="dv">255</span>));
}</code></pre>
<p>We can leave the update() and draw() functions as they were. Now,let's start making 'daughter' versions of this 'mother' class. Create a new Class set of files and name them 'ofBallBlue'. Feel free to copy the code below and it's '.h' shoudl look like this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#pragma once                </span><span class="co">// another and more modern way to prevent the compiler from including this file more than once</span>

<span class="ot">#include "ofMain.h"</span>
<span class="ot">#include "ofBall.h"            </span><span class="co">// we need to include the 'mother' class, the compiler will include the mother/base class so we have access to all the methods inherited</span>

<span class="kw">class</span> ofBallBlue : <span class="kw">public</span> ofBall {     <span class="co">// we set the class to inherit from 'ofBall'</span>

<span class="kw">public</span>: 

    <span class="dt">void</span> draw();             <span class="co">// this is the only methid we actually want to be different from the 'mother class'</span>

};</code></pre>
<p>On the '.cpp' file we'll need to them specify what we want the new 'draw()' method to do uniquely.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include "ofBallBlue.h"</span>


<span class="dt">void</span> ofBallBlue::draw(){
    ofSetColor(ofColor::blue);    <span class="co">// this is a shortcut for full blue color ;)</span>
    ofCircle(x, y, dim);    
}</code></pre>
<p>Now, on your own, create two new classes: ofBallRed and ofBallGreen based on ofBall class like ofBlue is. Back to your testApp.h, include the newly made classes and create one instance of each and in your testApp.cpp file initialize them and call their update() and draw() methods. A quick trick! right before you call the draw method, make this call:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">ofEnableBlendMode(OF_BLENDMODE_ADD);</code></pre>
<p>This will make your application drawing methods have an Additive Blending Mode. For more on this check Chapter??.</p>
<p>Hope you enjoyed this short tutorial! have fun!</p>
<div class="footer">
<div id="prev_chapter"><a href="intro_to_graphics.html">&lt; Graphics</a></div>
<div id="next_chapter"><a href="animation.html">Animation &gt;</a></div>
</div>
</div>
</div>
</body>
</html>
